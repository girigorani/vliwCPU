//===-- NewTargetISelDAGToDAG.cpp - A Dag to Dag Inst Selector for NewTarget --------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the NewTarget target.
//
//===----------------------------------------------------------------------===//

#include "NewTarget.h"
//#include "MCTargetDesc/NewTargetBaseInfo.h"
//#include "NewTargetAnalyzeImmediate.h"
#include "NewTargetMachineFunction.h"
#include "NewTargetRegisterInfo.h"
#include "NewTargetSubtarget.h"
#include "NewTargetMachine.h"
#include "llvm/CodeGen/MachineConstantPool.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/CodeGen/SelectionDAGNodes.h"
#include "llvm/IR/GlobalValue.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/Intrinsics.h"
#include "llvm/IR/Type.h"
#include "llvm/Support/CFG.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Target/TargetMachine.h"
#include <iostream>
using namespace llvm;

//===----------------------------------------------------------------------===//
// Instruction Selector Implementation
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// NewTargetDAGToDAGISel - NewTarget specific code to select NewTarget machine
// instructions for SelectionDAG operations.
//===----------------------------------------------------------------------===//
namespace llvm {

    class NewTargetDAGToDAGISel : public SelectionDAGISel {
        /// TM - Keep a reference to NewTargetTargetMachine.
        NewTargetMachine &TM;

        /// Subtarget - Keep a pointer to the NewTargetSubtarget around so that we can
        /// make the right decision when generating code for different targets.
        const NewTargetSubtarget &Subtarget;

    public:

        explicit NewTargetDAGToDAGISel(NewTargetMachine &tm) :
        SelectionDAGISel(tm),
        TM(tm), Subtarget(tm.getSubtarget<NewTargetSubtarget>()) {
        }

        // Pass Name

        virtual const char *getPassName() const {
            return "NewTarget DAG->DAG Pattern Instruction Selection";
        }

        virtual bool runOnMachineFunction(MachineFunction &MF);

    private:
        // Include the pieces autogenerated from the target description.
#include "NewTargetGenDAGISel.inc"

        void ProcessFunctionAfterISel(MachineFunction &MF);
        SDNode *Select(SDNode *N);

        // Complex Pattern.
        /// (reg + imm).
        bool selectAddrRegImm(SDValue Addr, SDValue &Base, SDValue &Offset) const;

        /// Match integer address pattern.
        bool selectIntAddr(SDValue Addr, SDValue &Base, SDValue &Offset) const;

        /// Fall back on this function if all else fails.
        bool selectAddrDefault(SDValue Addr, SDValue &Base, SDValue &Offset) const;

        /// getTargetMachine - Return a reference to the TargetMachine, casted
        /// to the target-specific type.

        const NewTargetMachine &getTargetMachine() {
            return static_cast<const NewTargetMachine &> (TM);
        }

        // getImm - Return a target constant with the specified value.

        inline SDValue getImm(const SDNode *Node, unsigned Imm) {
            return CurDAG->getTargetConstant(Imm, Node->getValueType(0));
        }

        SDNode *SelectSelect(SDNode *N);

        std::pair<SDNode*, SDNode*> SelectMULT(SDNode *N, unsigned Opc, DebugLoc dl,
                EVT Ty, bool HasLo, bool HasHi);

        SDNode *SelectZeroExtend(SDNode *N);

        SDNode* SelectLoad(SDNode *Node);
        SDNode* SelectStore(SDNode *Node);

        virtual bool SelectInlineAsmMemoryOperand(const SDValue &Op,
                char ConstraintCode,
                std::vector<SDValue> &OutOps);
    };

}

void NewTargetDAGToDAGISel::ProcessFunctionAfterISel(MachineFunction &MF) {
    //std::cout << "NewTargetDAGToDAGISel::ProcessFunctionAfterISel not implemented\n";
}

bool NewTargetDAGToDAGISel::runOnMachineFunction(MachineFunction &MF) {
    bool Ret = SelectionDAGISel::runOnMachineFunction(MF);
    
    ProcessFunctionAfterISel(MF);

    return Ret;
}

/// ComplexPattern used on MipsInstrInfo
/// Used on Mips Load/Store instructions

bool NewTargetDAGToDAGISel::selectAddrRegImm(SDValue Addr, SDValue &Base,
        SDValue &Offset) const {
    EVT ValTy = Addr.getValueType();
    // if Address is FI, get the TargetFrameIndex.
    if (FrameIndexSDNode * FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
        Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), ValTy);
        Offset = CurDAG->getTargetConstant(0, ValTy);
        return true;
    }
    /*
      // on PIC code Load GA
      if (Addr.getOpcode() == MipsISD::Wrapper) {
        Base   = Addr.getOperand(0);
        Offset = Addr.getOperand(1);
        return true;
      }
     */

    if (TM.getRelocationModel() != Reloc::PIC_) {
        if ((Addr.getOpcode() == ISD::TargetExternalSymbol ||
                Addr.getOpcode() == ISD::TargetGlobalAddress))
            return false;
    }

    // Addresses of the form FI+const or FI|const
    if (CurDAG->isBaseWithConstantOffset(Addr)) {
        ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1));
        // imediates arr 9 bits in ST200
        if (isInt<8>(CN->getSExtValue())) {

            // If the first operand is a FI, get the TargetFI Node
            if (FrameIndexSDNode * FIN = dyn_cast<FrameIndexSDNode>
                    (Addr.getOperand(0)))
                Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), ValTy);
            else
                Base = Addr.getOperand(0);

            Offset = CurDAG->getTargetConstant(CN->getZExtValue(), ValTy);
            return true;
        }
    }

    // Operand is a result from an ADD.
    if (Addr.getOpcode() == ISD::ADD) {
        // When loading from constant pools, load the lower address part in
        // the instruction itself. Example, instead of:
        //  lui $2, %hi($CPI1_0)
        //  addiu $2, $2, %lo($CPI1_0)
        //  lwc1 $f0, 0($2)
        // Generate:
        //  lui $2, %hi($CPI1_0)
        //  lwc1 $f0, %lo($CPI1_0)($2)
        if (Addr.getOperand(1).getOpcode() == NewTargetISD::Lo) {
            SDValue Opnd0 = Addr.getOperand(1).getOperand(0);
            if (isa<ConstantPoolSDNode>(Opnd0) || isa<GlobalAddressSDNode>(Opnd0) ||
                    isa<JumpTableSDNode>(Opnd0)) {
                Base = Addr.getOperand(0);
                Offset = Opnd0;
                return true;
            }
        }
    }

    return false;
}

bool NewTargetDAGToDAGISel::selectAddrDefault(SDValue Addr, SDValue &Base,
        SDValue &Offset) const {
    Base = Addr;
    Offset = CurDAG->getTargetConstant(0, Addr.getValueType());
    return true;
}

bool NewTargetDAGToDAGISel::selectIntAddr(SDValue Addr, SDValue &Base,
        SDValue &Offset) const {

    //std::cout << "NewTargetDAGToDAGISel::selectIntAddr may be incomplete \n";
    return selectAddrRegImm(Addr, Base, Offset) ||
            selectAddrDefault(Addr, Base, Offset);

    //return selectAddrDefault(Addr, Base, Offset);
}


/// Select instructions not customized! Used for
/// expanded, promoted and normal instructions

SDNode* NewTargetDAGToDAGISel::Select(SDNode *Node) {
    //TODO
    //std::cout << "=== Selection: " << Node->getOperationName(CurDAG) << "\n";
    //Node->dumpr(CurDAG);
    unsigned Opcode = Node->getOpcode();
    DebugLoc dl = Node->getDebugLoc();


    // Dump information about the Node being selected
    DEBUG(errs() << "Selecting: "; Node->dump(CurDAG); errs() << "\n");

    // If we have a custom node, we already have selected!
    if (Node->isMachineOpcode()) {
        DEBUG(errs() << "== "; Node->dump(CurDAG); errs() << "\n");
        return NULL;
    }

    ///
    // Instruction Selection not handled by the auto-generated
    // tablegen selection should be handled here.
    ///
    EVT NodeTy = Node->getValueType(0);
    unsigned MultOpc;

    switch (Opcode) {
        default:
        {
            //std::cout << "Default opcode: " << Opcode << "\n";
            break;
        }

        case ISD::SUBE:
        case ISD::ADDE:
        {
            SDValue InFlag = Node->getOperand(2), CmpLHS;
            unsigned Opc = InFlag.getOpcode();
            (void) Opc;
            assert(((Opc == ISD::ADDC || Opc == ISD::ADDE) ||
                    (Opc == ISD::SUBC || Opc == ISD::SUBE)) &&
                    "(ADD|SUB)E flag operand must come from (ADD|SUB)C/E insn");

            unsigned MOp;
            if (Opcode == ISD::ADDE) {
                CmpLHS = InFlag.getValue(0);
                MOp = NewTarget::ADD;
            } else {
                CmpLHS = InFlag.getOperand(0);
                MOp = NewTarget::SUB;
            }

            SDValue Ops[] = {CmpLHS, InFlag.getOperand(1)};

            SDValue LHS = Node->getOperand(0);
            SDValue RHS = Node->getOperand(1);

            EVT VT = LHS.getValueType();

            unsigned Sltu_op = NewTarget::CMPLTuBR;
            SDNode *Carry = CurDAG->getMachineNode(Sltu_op, dl, VT, Ops, 2);
            unsigned Add_op = NewTarget::ADD;
            SDNode *AddCarry = CurDAG->getMachineNode(Add_op, dl, VT,
                    SDValue(Carry, 0), RHS);

            return CurDAG->SelectNodeTo(Node, MOp, VT, MVT::Glue,
                    LHS, SDValue(AddCarry, 0));
        }

            /// Mul with two results
        case ISD::SMUL_LOHI:
        case ISD::UMUL_LOHI:
        {
            if (NodeTy == MVT::i32) {
                MultOpc = (Opcode == ISD::UMUL_LOHI ? NewTarget::MUL64hu : NewTarget::MUL64h);
            } else {
                llvm_unreachable("SMUL_LOHI/UMUL_LOHI not supported for i64");
            }

            std::pair<SDNode*, SDNode*> LoHi = SelectMULT(Node, MultOpc, dl, NodeTy,
                    true, true);

            if (!SDValue(Node, 0).use_empty())
                ReplaceUses(SDValue(Node, 0), SDValue(LoHi.first, 0));

            if (!SDValue(Node, 1).use_empty())
                ReplaceUses(SDValue(Node, 1), SDValue(LoHi.second, 0));

            return NULL;
        }

            /// Special Muls
        case ISD::MUL:
        {
            if (NodeTy == MVT::i32) {
                break;
            }
            llvm_unreachable("Mul not supported.");

        }
        case ISD::MULHS:
        case ISD::MULHU:
        {
            if (NodeTy == MVT::i32) {

                MultOpc = (Opcode == ISD::MULHU ? NewTarget::MUL64hu : NewTarget::MUL64h);
            } else {

                llvm_unreachable("MVT != i32 not supported.");
            }
            return SelectMULT(Node, MultOpc, dl, NodeTy, false, true).second;
        }

            // Get target GOT address.
        case ISD::GLOBAL_OFFSET_TABLE:
        {
            //std::cout << "ISD::GLOBAL_OFFSET_TABLE \n";
            return NULL;
        }


        case ISD::ConstantFP:
        {
            //std::cout << "ISD::ConstantFP\n";
            return NULL;
        }

        case ISD::SELECT:
        {
            //std::cout << "SELECTTTTTTTTTTTTTT\n";
            return SelectSelect(Node);
            break;
        }


        case ISD::Constant:
        {
            //std::cout << "É constante\n";
            //Node->dump();
            const ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Node);
            unsigned Size = CN->getValueSizeInBits(0);
            if (Size == 32) {
                //std::cout << "É 32 bits\n";
                break;
            }

        }

        case ISD::LOAD:
        {
            //return SelectLoad(Node);
            break;
        }
        case ISD::STORE:
        {
            //return SelectStore(Node);
            break;
        }
        case ISD::ZERO_EXTEND:
        {
            //return SelectZeroExtend(Node);
            break;
        }
        case NewTargetISD::SUBE:
        case NewTargetISD::ADDE:
        {
            unsigned opcode = (Opcode == NewTargetISD::SUBE ? NewTarget::NewTargetSUBE : NewTarget::NewTargetADDE);

            DebugLoc dl = Node->getDebugLoc();
            SDValue op1 = Node->getOperand(0);
            SDValue op2 = Node->getOperand(1);
            SDValue flag = Node->getOperand(2);


            SDNode* Newadde = CurDAG->getMachineNode(opcode, dl, MVT::i32, MVT::i32, op1, op2, flag);

            return Newadde;
        }
        case NewTargetISD::SUBC:
        case NewTargetISD::ADDC:
        {
            unsigned opcode = (Opcode == NewTargetISD::SUBC ? NewTarget::NewTargetSUBC : NewTarget::NewTargetADDC);

            DebugLoc dl = Node->getDebugLoc();
            SDValue op1 = Node->getOperand(0);
            SDValue op2 = Node->getOperand(1);


            SDNode* Newaddc = CurDAG->getMachineNode(opcode, dl, MVT::i32, MVT::i32, op1, op2);

            return Newaddc;
        }

    }
    // Select the default instruction
    SDNode *ResNode = SelectCode(Node);

    // if (ResNode == NULL || ResNode == Node){
    //       std::cout << "=== Selection: " << Node->getOperationName(CurDAG) << "\n";
    //       Node->dump(CurDAG);
    // }

    //if(Opcode == ISD::EntryToken){
    //    Node->dump();
    //ResNode->dump();
    //}


    return ResNode;
}

SDNode *NewTargetDAGToDAGISel::SelectSelect(SDNode *N) {
    DebugLoc dl = N->getDebugLoc();
    SDValue Cond = N->getOperand(0);
    SDValue ValTrue = N->getOperand(1);
    SDValue ValFalse = N->getOperand(2);
    SDNode *NewNode = N;
    /*  
      if (Cond.getValueType() == MVT::i32) {
          SDNode* Reg = CurDAG->getMachineNode(NewTarget::ORLBR, dl, MVT::i1,
                  Cond, CurDAG->getTargetConstant(0, MVT::i32));

          SDValue NewCond = SDValue(Reg, 0);

          SDValue NewSelect = CurDAG->getNode(ISD::SELECT, dl, MVT::i32, Cond, ValTrue, ValFalse);

          NewNode = NewSelect.getNode();
      }
     */

    SDNode* NewSelect = CurDAG->getMachineNode(NewTarget::NewTargetSelect, dl, MVT::i32, Cond, ValTrue, ValFalse);


    // remover codigo abaixo
    return NewSelect;

    std::cout << "AQUIIIIIIIIII\n";
    return SelectCode(NewNode);
    std::cout << "AQUIIIIIIIIII!!!!!!!!!!\n";
}

/// createMipsISelDag - This pass converts a legalized DAG into a
/// MIPS-specific DAG, ready for instruction scheduling.

FunctionPass *llvm::createNewTargetISelDag(NewTargetMachine &TM) {
    return new NewTargetDAGToDAGISel(TM);
}

/// Select multiply instructions.

std::pair<SDNode*, SDNode*>
NewTargetDAGToDAGISel::SelectMULT(SDNode *N, unsigned Opc, DebugLoc dl, EVT Ty,
        bool HasLo, bool HasHi) {
    SDNode *Lo = 0, *Hi = 0;
    // SDNode *Mul = CurDAG->getMachineNode(Opc, dl, MVT::Glue, N->getOperand(0),
    //         N->getOperand(1));
    // SDValue InFlag = SDValue(Mul, 0);

    if (HasLo) {
        unsigned Opcode = NewTarget::MUL32;
        Lo = CurDAG->getMachineNode(Opcode, dl, Ty, N->getOperand(0), N->getOperand(1));
    }
    if (HasHi) {
        unsigned Opcode = Opc;
        Hi = CurDAG->getMachineNode(Opcode, dl, Ty, N->getOperand(0), N->getOperand(1));
    }
    return std::make_pair(Lo, Hi);
}

SDNode *NewTargetDAGToDAGISel::SelectZeroExtend(SDNode *N) {
    //DebugLoc dl = N->getDebugLoc();
    SDNode *Op0 = N->getOperand(0).getNode();

    if (N->getValueType(0) == MVT::i32 && Op0->getValueType(0) == MVT::i1) {

        llvm_unreachable("oops");

        /*
        SDNode* OneReg = CurDAG->getMachineNode(NewTarget::ADDi, dl, MVT::i32,
                CurDAG->getRegister(NewTarget::ZERO, MVT::i32),
                CurDAG->getTargetConstant(1, MVT::i32));

        SDNode* Result = CurDAG->getMachineNode(NewTarget::CMOV, dl, MVT::i32,
                SDValue(Op0, 0), SDValue(OneReg, 0));

        SDNode* NegOp0 = CurDAG->getMachineNode(NewTarget::NANDL, dl, MVT::i1,
                SDValue(Op0, 0), SDValue(Op0, 0));

        SDNode* Result2 = CurDAG->getMachineNode(NewTarget::CMOV, dl, MVT::i32,
                SDValue(NegOp0, 0),
                CurDAG->getRegister(NewTarget::ZERO, MVT::i32));


        ReplaceUses(N, Result);
        
        return Result;
         */


    }

    //Op0->dump();

    //llvm_unreachable("aqui");

    return SelectCode(N);
}

SDNode* NewTargetDAGToDAGISel::SelectLoad(SDNode *Node) {
    SDNode *NewNode = Node;
    DebugLoc dl = Node->getDebugLoc();
    LoadSDNode *LD = cast<LoadSDNode>(Node);
    const SDValue Op1 = LD->getBasePtr();

    if (Op1->getOpcode() == ISD::FrameIndex) {
        FrameIndexSDNode *FI = cast<FrameIndexSDNode>(Op1);
        int64_t Imm = FI->getIndex()*4 + 4;

        SDNode* AddReg = CurDAG->getMachineNode(NewTarget::ADDi, dl, MVT::i32,
                CurDAG->getRegister(NewTarget::SP, MVT::i32),
                CurDAG->getTargetConstant(Imm, MVT::i32));

        SDValue NewReg = SDValue(AddReg, 0);
        SDValue NewStore = CurDAG->getLoad(MVT::i32, dl, LD->getChain(), NewReg,
                MachinePointerInfo(), false, false, false, 0);

        NewNode = NewStore.getNode();

    } else if (Op1->getOpcode() == ISD::ADD) {

        SDNode* AddReg;

        if (LD->getBasePtr()->getOperand(1)->getOpcode() == ISD::Constant) {

            ConstantSDNode *Off = cast<ConstantSDNode>(LD->getBasePtr()->getOperand(1));

            AddReg = CurDAG->getMachineNode(NewTarget::ADDi, dl, MVT::i32,
                    LD->getBasePtr()->getOperand(0),
                    CurDAG->getTargetConstant(Off->getSExtValue(), MVT::i32));

        } else {
            AddReg = CurDAG->getMachineNode(NewTarget::ADD, dl, MVT::i32,
                    LD->getBasePtr()->getOperand(0),
                    LD->getBasePtr()->getOperand(1));
        }

        SDValue NewReg = SDValue(AddReg, 0);
        SDValue NewStore = CurDAG->getLoad(MVT::i32, dl, LD->getChain(), NewReg,
                MachinePointerInfo(), false, false, false, 0);
        NewNode = NewStore.getNode();

    }

    return SelectCode(NewNode);
}

SDNode* NewTargetDAGToDAGISel::SelectStore(SDNode *Node) {


    std::cout << "ANTESSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS\n";

    //Node->dump();

    SDNode *NewNode = Node;
    SDValue Chain = Node->getOperand(0);
    DebugLoc dl = Node->getDebugLoc();
    StoreSDNode *ST = cast<StoreSDNode>(Node);
    const SDValue Op1 = ST->getBasePtr();

    if (Op1->getOpcode() == ISD::FrameIndex) {
        FrameIndexSDNode *FI = cast<FrameIndexSDNode>(Op1);
        int64_t Imm = FI->getIndex()*4 + 4;

        SDNode* AddReg = CurDAG->getMachineNode(NewTarget::ADDi, dl, MVT::i32,
                CurDAG->getRegister(NewTarget::SP, MVT::i32),
                CurDAG->getTargetConstant(Imm, MVT::i32));

        SDValue NewReg = SDValue(AddReg, 0);
        SDValue NewOff = CurDAG->getTargetConstant(0, MVT::i32);

        //std::cout << "selecting store 1\n";
        //ST->getChain().dump();

        SDValue NewStore = CurDAG->getStore(Chain, dl, NewOff, NewReg,
                ST->getMemOperand());

        NewNode = NewStore.getNode();

    } else if (Op1->getOpcode() == ISD::ADD) {

        std::cout << "selecting store 2";

        SDNode* AddReg;

        if (Op1->getOperand(1).getOpcode() == ISD::Constant) {
            ConstantSDNode *Off = cast<ConstantSDNode>(ST->getBasePtr()->getOperand(1));

            AddReg = CurDAG->getMachineNode(NewTarget::ADDi, dl, MVT::i32,
                    ST->getBasePtr()->getOperand(0),
                    CurDAG->getTargetConstant(Off->getSExtValue(), MVT::i32));
        } else {
            AddReg = CurDAG->getMachineNode(NewTarget::ADD, dl, MVT::i32,
                    ST->getBasePtr()->getOperand(0),
                    ST->getBasePtr()->getOperand(1));
        }

        SDValue NewReg = SDValue(AddReg, 0);
        SDValue NewOff = CurDAG->getTargetConstant(0, MVT::i32);
        SDValue NewStore = CurDAG->getStore(ST->getChain(), dl, NewOff, NewReg,
                ST->getMemOperand());
        NewNode = NewStore.getNode();

    }

    std::cout << "DEPOISSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS\n";

    //NewNode->dump();

    return SelectCode(NewNode);
}

bool NewTargetDAGToDAGISel::
SelectInlineAsmMemoryOperand(const SDValue &Op, char ConstraintCode,
        std::vector<SDValue> &OutOps) {
    assert(ConstraintCode == 'm' && "unexpected asm memory constraint");
    OutOps.push_back(Op);
    return false;
}
